<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Space Invaders - Mobile Friendly</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
 
  <style>
    body {
      margin: 0;
      background: #000;
      color: #0f0;
      font-family: monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      height: 100vh;
      overflow: hidden;
    }
 
    #ui {
      margin-top: 8px;
      display: flex;
      gap: 20px;
      align-items: center;
      justify-content: center;
      color: #0f0;
      z-index: 2;
    }
 
    #ui span {
      min-width: 90px;
      text-align: center;
    }
 
    #info {
      margin-top: 4px;
      font-size: 11px;
      color: #8f8;
      text-align: center;
      padding: 0 8px;
    }
 
    canvas {
      border: 2px solid #0f0;
      margin-top: 8px;
      background: #000;
      max-width: 100%;
      height: auto;
      touch-action: none; /* prevent weird scrolling while playing */
    }
 
    #btnRestart {
      padding: 4px 8px;
      border: 1px solid #0f0;
      background: transparent;
      color: #0f0;
      cursor: pointer;
      font-family: inherit;
    }
 
    #btnRestart:hover {
      background: #030;
    }
 
    /* MOBILE CONTROLS */
 
    #mobileControls {
      position: fixed;
      bottom: 10px;
      left: 0;
      width: 100%;
      display: flex;
      justify-content: space-around;
      align-items: center;
      pointer-events: auto;
      z-index: 3;
    }
 
    #mobileControls button {
      width: 80px;
      height: 80px;
      font-size: 26px;
      border-radius: 12px;
      background: #111;
      border: 2px solid #0f0;
      color: #0f0;
      font-family: monospace;
    }
 
    #mobileControls button:active {
      background: #030;
    }
 
    /* Slightly smaller buttons on very small screens */
    @media (max-width: 400px) {
      #mobileControls button {
        width: 65px;
        height: 65px;
        font-size: 22px;
      }
    }
 
    /* Hide mobile controls on bigger desktop screens if you want */
    @media (min-width: 900px) {
      #mobileControls {
        bottom: 16px;
      }
    }
  </style>
</head>
<body>
  <div id="ui">
    <span id="scoreLabel">Score: 0</span>
    <span id="livesLabel">Lives: 3</span>
    <button id="btnRestart">Restart</button>
  </div>
  <div id="info">
    Desktop: &larr; &rarr; to move, Space to shoot, P to pause &nbsp;|&nbsp;
    Mobile: use on-screen buttons
  </div>
 
  <canvas id="game" width="600" height="400"></canvas>
 
  <!-- MOBILE CONTROLS -->
  <div id="mobileControls">
    <button id="btnLeft">⟵</button>
    <button id="btnFire">FIRE</button>
    <button id="btnRight">⟶</button>
  </div>
 
  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
 
    const scoreLabel = document.getElementById("scoreLabel");
    const livesLabel = document.getElementById("livesLabel");
    const btnRestart = document.getElementById("btnRestart");
 
    const btnLeft = document.getElementById("btnLeft");
    const btnRight = document.getElementById("btnRight");
    const btnFire = document.getElementById("btnFire");
 
    const WIDTH = canvas.width;
    const HEIGHT = canvas.height;
 
    // GAME STATE
    let keys = {};
    let player;
    let bullets = [];
    let enemyBullets = [];
    let invaders = [];
    let invaderDirection = 1; // 1 = right, -1 = left
    let lastInvaderStep = 0;
    let invaderStepInterval = 600; // ms
    let lastEnemyShoot = 0;
    let enemyShootInterval = 800; // ms
    let score = 0;
    let lives = 3;
    let gameOver = false;
    let paused = false;
 
    // PLAYER
    function createPlayer() {
      return {
        x: WIDTH / 2 - 15,
        y: HEIGHT - 50,
        w: 30,
        h: 20,
        speed: 4,
        shootCooldown: 250, // ms
        lastShot: 0,
      };
    }
 
    // INVADERS
    function createInvaders() {
      const rows = 4;
      const cols = 10;
      const invadersArr = [];
      const marginTop = 40;
      const marginSide = 40;
      const spacingX = 40;
      const spacingY = 30;
      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          invadersArr.push({
            x: marginSide + col * spacingX,
            y: marginTop + row * spacingY,
            w: 24,
            h: 18,
            alive: true,
          });
        }
      }
      return invadersArr;
    }
 
    function resetGame() {
      player = createPlayer();
      bullets = [];
      enemyBullets = [];
      invaders = createInvaders();
      invaderDirection = 1;
      lastInvaderStep = 0;
      lastEnemyShoot = 0;
      score = 0;
      lives = 3;
      gameOver = false;
      paused = false;
      updateUI();
    }
 
    function updateUI() {
      scoreLabel.textContent = "Score: " + score;
      livesLabel.textContent = "Lives: " + lives;
    }
 
    // INPUT: KEYBOARD
    window.addEventListener("keydown", (e) => {
      if (["ArrowLeft", "ArrowRight", "Space"].includes(e.code)) {
        e.preventDefault(); // avoid scrolling
      }
      keys[e.code] = true;
 
      if (e.code === "KeyP") {
        paused = !paused && !gameOver;
      }
    });
 
    window.addEventListener("keyup", (e) => {
      keys[e.code] = false;
    });
 
    // INPUT: MOBILE TOUCH CONTROLS
    function handleTouchStart(button, keyCode) {
      button.addEventListener("touchstart", (e) => {
        e.preventDefault();
        keys[keyCode] = true;
      });
    }
 
    function handleTouchEnd(button, keyCode) {
      button.addEventListener("touchend", (e) => {
        e.preventDefault();
        keys[keyCode] = false;
      });
      button.addEventListener("touchcancel", (e) => {
        e.preventDefault();
        keys[keyCode] = false;
      });
    }
 
    handleTouchStart(btnLeft, "ArrowLeft");
    handleTouchEnd(btnLeft, "ArrowLeft");
 
    handleTouchStart(btnRight, "ArrowRight");
    handleTouchEnd(btnRight, "ArrowRight");
 
    handleTouchStart(btnFire, "Space");
    handleTouchEnd(btnFire, "Space");
 
    btnRestart.addEventListener("click", () => {
      resetGame();
    });
 
    // GAME LOOP
    let lastTime = 0;
    function loop(timestamp) {
      const dt = timestamp - lastTime;
      lastTime = timestamp;
 
      if (!paused && !gameOver) {
        update(dt, timestamp);
      }
      draw();
 
      requestAnimationFrame(loop);
    }
 
    function update(dt, now) {
      // Player movement
      if (keys["ArrowLeft"]) {
        player.x -= player.speed;
      }
      if (keys["ArrowRight"]) {
        player.x += player.speed;
      }
      // Clamp player within bounds
      player.x = Math.max(0, Math.min(WIDTH - player.w, player.x));
 
      // Player shooting
      if (keys["Space"] && now - player.lastShot > player.shootCooldown) {
        bullets.push({
          x: player.x + player.w / 2 - 2,
          y: player.y,
          w: 4,
          h: 10,
          vy: -6,
        });
        player.lastShot = now;
      }
 
      // Move bullets
      bullets.forEach((b) => {
        b.y += b.vy;
      });
      bullets = bullets.filter((b) => b.y + b.h > 0);
 
      // Invader movement (step style)
      if (now - lastInvaderStep > invaderStepInterval) {
        lastInvaderStep = now;
 
        // Check if invaders hit side
        let shouldDescend = false;
        for (const inv of invaders) {
          if (!inv.alive) continue;
          const nextX = inv.x + invaderDirection * 10;
          if (nextX < 10 || nextX + inv.w > WIDTH - 10) {
            shouldDescend = true;
            break;
          }
        }
 
        if (shouldDescend) {
          invaderDirection *= -1;
          for (const inv of invaders) {
            if (!inv.alive) continue;
            inv.y += 12;
            // If invader reaches bottom, player loses
            if (inv.y + inv.h >= player.y) {
              lives = 0;
              handlePlayerHit();
            }
          }
        } else {
          for (const inv of invaders) {
            if (!inv.alive) continue;
            inv.x += invaderDirection * 10;
          }
        }
      }
 
      // Enemy shooting
      if (now - lastEnemyShoot > enemyShootInterval) {
        lastEnemyShoot = now;
        enemyShoot();
      }
 
      // Move enemy bullets
      enemyBullets.forEach((b) => {
        b.y += b.vy;
      });
      enemyBullets = enemyBullets.filter((b) => b.y < HEIGHT + 20);
 
      // Collisions: bullets vs invaders
      for (const b of bullets) {
        for (const inv of invaders) {
          if (!inv.alive) continue;
          if (rectIntersect(b, inv)) {
            inv.alive = false;
            b.dead = true;
            score += 10;
          }
        }
      }
      bullets = bullets.filter((b) => !b.dead);
 
      // Collisions: enemy bullets vs player
      for (const b of enemyBullets) {
        if (rectIntersect(b, player)) {
          b.dead = true;
          handlePlayerHit();
        }
      }
      enemyBullets = enemyBullets.filter((b) => !b.dead);
 
      // Check win condition (all invaders dead)
      if (!invaders.some((inv) => inv.alive)) {
        // Next wave: recreate invaders slightly faster
        invaders = createInvaders();
        invaderStepInterval = Math.max(200, invaderStepInterval - 50);
        if (enemyShootInterval > 300) {
          enemyShootInterval -= 40;
        }
      }
 
      updateUI();
    }
 
    function handlePlayerHit() {
      lives -= 1;
      if (lives <= 0) {
        lives = 0;
        gameOver = true;
      } else {
        // temporary "respawn" – clear bullets and move player to center
        enemyBullets = [];
        player.x = WIDTH / 2 - player.w / 2;
      }
      updateUI();
    }
 
    function enemyShoot() {
      // Pick a random column of invaders and shoot from the bottom-most alive one
      const aliveInvaders = invaders.filter((inv) => inv.alive);
      if (aliveInvaders.length === 0) return;
 
      const byColumn = {};
      for (const inv of aliveInvaders) {
        const colKey = Math.round(inv.x / 40); // approximate column
        if (!byColumn[colKey] || byColumn[colKey].y < inv.y) {
          byColumn[colKey] = inv;
        }
      }
 
      const columns = Object.keys(byColumn);
      const randomCol = columns[Math.floor(Math.random() * columns.length)];
      const shooter = byColumn[randomCol];
 
      enemyBullets.push({
        x: shooter.x + shooter.w / 2 - 2,
        y: shooter.y + shooter.h,
        w: 4,
        h: 10,
        vy: 4,
      });
    }
 
    function rectIntersect(a, b) {
      return (
        a.x < b.x + b.w &&
        a.x + a.w > b.x &&
        a.y < b.y + b.h &&
        a.y + a.h > b.y
      );
    }
 
    // DRAWING
    function draw() {
      ctx.clearRect(0, 0, WIDTH, HEIGHT);
 
      // background
      drawStars();
 
      // player (triangle ship + cockpit)
      if (!gameOver) {
        ctx.fillStyle = "#0f0";
 
        // body (triangle)
        ctx.beginPath();
        ctx.moveTo(player.x, player.y + player.h);                  // left bottom
        ctx.lineTo(player.x + player.w, player.y + player.h);       // right bottom
        ctx.lineTo(player.x + player.w / 2, player.y);              // top center
        ctx.closePath();
        ctx.fill();
 
        // cockpit (small rectangle)
        ctx.fillRect(
          player.x + player.w / 2 - 3,
          player.y + player.h / 2 - 4,
          6,
          8
        );
      }
 
      // bullets (player)
      ctx.fillStyle = "#0f0";
      bullets.forEach((b) => {
        ctx.fillRect(b.x, b.y, b.w, b.h);
      });
 
      // enemy bullets
      ctx.fillStyle = "#f00";
      enemyBullets.forEach((b) => {
        ctx.fillRect(b.x, b.y, b.w, b.h);
      });
 
      // invaders
      ctx.fillStyle = "#0ff";
      invaders.forEach((inv) => {
        if (!inv.alive) return;
        drawInvader(inv.x, inv.y, inv.w, inv.h);
      });
 
      // overlays
      if (paused && !gameOver) {
        drawCenteredText("PAUSED", HEIGHT / 2 - 10, 24);
        drawCenteredText("Press P to resume", HEIGHT / 2 + 15, 14);
      }
 
      if (gameOver) {
        drawCenteredText("GAME OVER", HEIGHT / 2 - 10, 24);
        drawCenteredText("Tap Restart to play again", HEIGHT / 2 + 15, 14);
      }
    }
 
    function drawCenteredText(text, y, size) {
      ctx.fillStyle = "#0f0";
      ctx.font = size + "px monospace";
      const width = ctx.measureText(text).width;
      ctx.fillText(text, (WIDTH - width) / 2, y);
    }
 
    // Fancy-ish invader using pixel pattern
    function drawInvader(x, y, w, h) {
      const cols = 11;
      const rows = 8;
      const pixelW = w / cols;
      const pixelH = h / rows;
 
      // 1 = pixel on, 0 = pixel off
      const pattern = [
        [0,0,1,0,0,0,0,1,0,0,0],
        [0,1,0,1,0,0,0,1,0,1,0],
        [1,0,0,0,1,1,1,0,0,0,1],
        [1,0,1,1,1,1,1,1,1,0,1],
        [1,0,1,1,1,1,1,1,1,0,1],
        [1,0,1,0,1,1,1,0,1,0,1],
        [0,0,0,1,0,0,0,1,0,0,0],
        [0,0,1,0,0,0,0,0,1,0,0],
      ];
 
      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          if (pattern[row][col]) {
            ctx.fillRect(
              x + col * pixelW,
              y + row * pixelH,
              pixelW,
              pixelH
            );
          }
        }
      }
    }
 
    function drawStars() {
      // simple random-ish static stars
      ctx.fillStyle = "#040";
      for (let i = 0; i < 40; i++) {
        const sx = (i * 73) % WIDTH;
        const sy = (i * 37) % HEIGHT;
        ctx.fillRect(sx, sy, 1, 1);
      }
    }
 
    // START
    resetGame();
    requestAnimationFrame(loop);
  </script>
</body>
</html>
